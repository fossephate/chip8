{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/CPU.js","webpack:///./src/Chip8.js","webpack:///./src/PPU.js","webpack:///./src/fontset.js","webpack:///./src/index.js"],"names":["randomNumbers","rNum","i","push","Math","round","random","CPU","constructor","opcode","memory","Uint8Array","V","keys","I","pc","delay_timer","sound_timer","stack","sp","drawFlag","gfx","init","chip8Fontset","loadROM","buffer","length","emulateCycle","VX","VY","NN","rand0t255","n","x","y","height","pixel","console","log","toString","yline","xline","keyPress","tick","keyList","Chip8","cpu","ppu","PPU","document","getElementById","render","key","isPressed","canvas","ctx","getContext","debugRender","lines","line","fillStyle","fillRect","openFile","cb","reader","FileReader","onload","event","arrayBuffer","target","result","array","readAsArrayBuffer","files","run","chip8","setTimeout","window","tickRateMS","main","querySelector","addEventListener","contents"],"mappings":"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AAC,GAAG,GAAhB,IAAuBuB,MAAM,CAACvB,CAAD,CAA7B;AACA;AACD;;AAEDyB,cAAY,GAAG;AACd,QAAIC,EAAE,GAAG,KAAKhB,CAAL,CAAO,CAAC,KAAKH,MAAL,GAAc,MAAf,KAA0B,CAAjC,CAAT;AACA,QAAIoB,EAAE,GAAG,KAAKjB,CAAL,CAAO,CAAC,KAAKH,MAAL,GAAc,MAAf,KAA0B,CAAjC,CAAT;AACA,QAAIqB,EAAJ;AACA,QAAIC,SAAJ;AACA,QAAIC,CAAJ;AACA,QAAIC,CAAJ,EAAOC,CAAP,EAAUC,MAAV,EAAkBC,KAAlB,CANc,CAQd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AACA,YAAQ,KAAK3B,MAAL,GAAc,MAAtB;AACC,WAAK,MAAL;AACC,gBAAQ,KAAKA,MAAL,GAAc,MAAtB;AACC,eAAK,MAAL;AAAa;AACZ,iBAAK,IAAIP,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,IAApB,EAA0B,EAAEA,CAA5B,EAA+B;AAC9B,mBAAKmB,GAAL,CAASnB,CAAT,IAAc,GAAd;AACA;;AACD,iBAAKkB,QAAL,GAAgB,IAAhB;AACA,iBAAKL,EAAL,IAAW,CAAX;AACA;;AAED,eAAK,MAAL;AAAa;AACZ,cAAE,KAAKI,EAAP,CADD,CACY;;AACX,iBAAKJ,EAAL,GAAU,KAAKG,KAAL,CAAW,KAAKC,EAAhB,CAAV,CAFD,CAEgC;;AAC/B,iBAAKJ,EAAL,IAAW,CAAX,CAHD,CAGe;;AACd;;AAED;AACCsB,mBAAO,CAACC,GAAR,CAAa,mBAA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","file":"index.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"bundles/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","import chip8Fontset from \"./fontset.js\";\r\n\r\nlet randomNumbers = [];\r\nlet rNum = 0;\r\nfor (let i = 0; i < 10000; i++) {\r\n\trandomNumbers.push(Math.round(Math.random() * 255));\r\n}\r\n\r\nexport default class CPU {\r\n\tconstructor() {\r\n\t\t// current opcode:\r\n\t\tthis.opcode = 0;\r\n\r\n\t\t// 4K of memory:\r\n\t\tthis.memory = new Uint8Array(4096);\r\n\r\n\t\t// 0x000-0x1FF - Chip 8 interpreter (contains font set in emu)\r\n\t\t// 0x050-0x0A0 - Used for the built in 4x5 pixel font set (0-F)\r\n\t\t// 0x200-0xFFF - Program ROM and work RAM\r\n\r\n\t\t// general purpose registers:\r\n\t\tthis.V = new Uint8Array(16);\r\n\r\n\t\t// keys (input):\r\n\t\tthis.keys = new Uint8Array(16);\r\n\r\n\t\tthis.I = 0; //\tindex\r\n\t\tthis.pc = 0; //\tprogram counter\r\n\r\n\t\tthis.delay_timer = 0;\r\n\t\tthis.sound_timer = 0;\r\n\r\n\t\t// stack:\r\n\t\tthis.stack = new Uint8Array(16);\r\n\t\tthis.sp = 0;\r\n\r\n\t\tthis.drawFlag = false;\r\n\r\n\t\t// 64 x 32px\r\n\t\tthis.gfx = new Uint8Array(2048);\r\n\t}\r\n\r\n\tinit() {\r\n\t\t// start at 0x200:\r\n\t\tthis.pc = 0x200;\r\n\t\tthis.opcode = 0;\r\n\t\tthis.I = 0;\r\n\t\tthis.sp = 0;\r\n\r\n\t\t// Clear display\r\n\t\tfor (let i = 0; i < 2048; i++) {\r\n\t\t\tthis.gfx[i] = 0;\r\n\t\t}\r\n\r\n\t\t// Clear stack\r\n\t\tfor (let i = 0; i < 16; i++) {\r\n\t\t\tthis.stack[i] = 0;\r\n\t\t}\r\n\r\n\t\tfor (let i = 0; i < 16; i++) {\r\n\t\t\tthis.keys[i] = 0;\r\n\t\t\tthis.V[i] = 0;\r\n\t\t}\r\n\r\n\t\t// Clear memory\r\n\t\tfor (let i = 0; i < 4096; i++) {\r\n\t\t\tthis.memory[i] = 0;\r\n\t\t}\r\n\r\n\t\t// load font set:\r\n\t\tfor (let i = 0; i < 80; i++) {\r\n\t\t\tthis.memory[i] = chip8Fontset[i];\r\n\t\t}\r\n\r\n\t\t// reset timers:\r\n\t\tthis.delay_timer = 0;\r\n\t\tthis.sound_timer = 0;\r\n\r\n\t\tthis.drawFlag = true;\r\n\t}\r\n\r\n\tloadROM(buffer) {\r\n\t\t// load rom:\r\n\t\tfor (let i = 0; i < buffer.length; i++) {\r\n\t\t\tthis.memory[i + 512] = buffer[i];\r\n\t\t}\r\n\t}\r\n\r\n\temulateCycle() {\r\n\t\tlet VX = this.V[(this.opcode & 0x0f00) >> 8];\r\n\t\tlet VY = this.V[(this.opcode & 0x00f0) >> 4];\r\n\t\tlet NN;\r\n\t\tlet rand0t255;\r\n\t\tlet n;\r\n\t\tlet x, y, height, pixel;\r\n\r\n\t\t// switch (this.opcode & 0xf000) {\r\n\t\t// \tcase 0x0000:\r\n\t\t// \t\tswitch (this.opcode & 0x000f) {\r\n\t\t// \t\t\tcase 0x0000:\r\n\t\t// \t\t\t\t// Display disp_clear() Clears the screen.\r\n\t\t// \t\t\t\t// Clear display\r\n\t\t// \t\t\t\tfor (let i = 0; i < 2048; i++) {\r\n\t\t// \t\t\t\t\tthis.gfx[i] = 0;\r\n\t\t// \t\t\t\t}\r\n\t\t// \t\t\t\tthis.drawFlag = true;\r\n\t\t// \t\t\t\tthis.pc += 2;\r\n\t\t// \t\t\t\tbreak;\r\n\t\t// \t\t\tcase 0x000e:\r\n\t\t// \t\t\t\t// Flow return; Returns from a subroutine.\r\n\t\t// \t\t\t\tthis.sp -= 1; // 16 levels of stack, decrease stack pointer to prevent overwrite\r\n\t\t// \t\t\t\tthis.pc = this.stack[this.sp]; // Put the stored return address from the stack back into the program counter\r\n\t\t// \t\t\t\tthis.pc += 2;\r\n\t\t// \t\t\t\tbreak;\r\n\t\t// \t\t\tdefault:\r\n\t\t// \t\t\t\tconsole.log(`Unknown opcode: ${this.opcode.toString(16)}`);\r\n\t\t// \t\t\t\tbreak;\r\n\t\t// \t\t}\r\n\t\t// \t\tbreak;\r\n\t\t// \tcase 0x1000: // 0x1XNN\r\n\t\t// \t\t// Flow goto NNN; Jumps to address NNN.\r\n\t\t// \t\tthis.pc = this.opcode & 0x0fff;\r\n\t\t// \t\tbreak;\r\n\t\t// \tcase 0x2000:\r\n\t\t// \t\t// Flow *(0xNNN)() Calls subroutine at NNN.\r\n\t\t// \t\tthis.stack[this.sp] = this.pc;\r\n\t\t// \t\tthis.sp += 1;\r\n\t\t// \t\tthis.pc = this.opcode & 0x0fff;\r\n\t\t// \t\tbreak;\r\n\t\t// \tcase 0x3000: // 0x3XNN\r\n\t\t// \t\t// Cond if(Vx==NN) Skips the next instruction if VX equals NN.\r\n\t\t// \t\t// (Usually the next instruction is a jump to skip a code block)\r\n\t\t// \t\tNN = this.opcode & 0x00ff;\r\n\t\t// \t\tif (VX === NN) {\r\n\t\t// \t\t\tthis.pc += 4;\r\n\t\t// \t\t} else {\r\n\t\t// \t\t\tthis.pc += 2;\r\n\t\t// \t\t}\r\n\t\t// \t\tbreak;\r\n\t\t// \tcase 0x4000: // 0x4XNN\r\n\t\t// \t\t// Cond if(Vx!=NN) Skips the next instruction if VX doesn't equal NN.\r\n\t\t// \t\t// (Usually the next instruction is a jump to skip a code block)\r\n\t\t// \t\tNN = this.opcode & 0x00ff;\r\n\t\t// \t\tif (VX !== NN) {\r\n\t\t// \t\t\tthis.pc += 4;\r\n\t\t// \t\t} else {\r\n\t\t// \t\t\tthis.pc += 2;\r\n\t\t// \t\t}\r\n\t\t// \t\tbreak;\r\n\t\t// \tcase 0x5000: // 0x5XY0\r\n\t\t// \t\t// Cond if(Vx==Vy) Skips the next instruction if VX equals VY.\r\n\t\t// \t\t// (Usually the next instruction is a jump to skip a code block)\r\n\t\t// \t\tif (VX === VY) {\r\n\t\t// \t\t\tthis.pc += 4;\r\n\t\t// \t\t} else {\r\n\t\t// \t\t\tthis.pc += 2;\r\n\t\t// \t\t}\r\n\t\t// \t\tbreak;\r\n\t\t// \tcase 0x6000: // 0x6XNN\r\n\t\t// \t\t// Const Vx = NN Sets VX to NN.\r\n\t\t// \t\tthis.V[(this.opcode & 0x0f00) >> 8] = this.opcode & 0x00ff;\r\n\t\t// \t\tthis.pc += 2;\r\n\t\t// \t\tbreak;\r\n\t\t// \tcase 0x7000: // 0x7XNN\r\n\t\t// \t\t// Const Vx += NN Adds NN to VX. (Carry flag is not changed)\r\n\t\t// \t\tthis.V[(this.opcode & 0x0f00) >> 8] += this.opcode & 0x00ff;\r\n\t\t// \t\tthis.pc += 2;\r\n\t\t// \t\tbreak;\r\n\t\t// \tcase 0x8000:\r\n\t\t// \t\tswitch (this.opcode & 0x000f) {\r\n\t\t// \t\t\tcase 0x0000: // 8XY0\r\n\t\t// \t\t\t\t// Assign Vx=Vy Sets VX to the value of VY.\r\n\t\t// \t\t\t\tthis.V[(this.opcode & 0x0f00) >> 8] = VY;\r\n\t\t// \t\t\t\tthis.pc += 2;\r\n\t\t// \t\t\t\tbreak;\r\n\t\t// \t\t\tcase 0x0001: // 8XY1\r\n\t\t// \t\t\t\t// BitOp Vx=Vx|Vy Sets VX to VX or VY. (Bitwise OR operation)\r\n\t\t// \t\t\t\tthis.V[(this.opcode & 0x0f00) >> 8] = VX | VY;\r\n\t\t// \t\t\t\tthis.pc += 2;\r\n\t\t// \t\t\t\tbreak;\r\n\t\t// \t\t\tcase 0x0002: // 8XY2\r\n\t\t// \t\t\t\t// BitOp Vx=Vx&Vy Sets VX to VX and VY. (Bitwise AND operation)\r\n\t\t// \t\t\t\tthis.V[(this.opcode & 0x0f00) >> 8] = VX & VY;\r\n\t\t// \t\t\t\tthis.pc += 2;\r\n\t\t// \t\t\t\tbreak;\r\n\t\t// \t\t\tcase 0x0003: // 8XY3\r\n\t\t// \t\t\t\t// BitOp Vx=Vx^Vy Sets VX to VX xor VY.\r\n\t\t// \t\t\t\tthis.V[(this.opcode & 0x0f00) >> 8] = VX ^ VY;\r\n\t\t// \t\t\t\tthis.pc += 2;\r\n\t\t// \t\t\t\tbreak;\r\n\t\t// \t\t\tcase 0x0004: // 8XY4\r\n\t\t// \t\t\t\t// Math Vx += Vy Adds VY to VX. VF is set to 1 when there's a carry, and to 0 when there isn't.\r\n\t\t// \t\t\t\tif (VY > 0xff - VX) {\r\n\t\t// \t\t\t\t\tthis.V[0xf] = 1; // carry\r\n\t\t// \t\t\t\t} else {\r\n\t\t// \t\t\t\t\tthis.V[0xf] = 0; // not\r\n\t\t// \t\t\t\t}\r\n\t\t// \t\t\t\tthis.V[(this.opcode & 0x0f00) >> 8] += VY;\r\n\t\t// \t\t\t\tthis.pc += 2;\r\n\t\t// \t\t\t\tbreak;\r\n\t\t// \t\t\tcase 0x0005: // 8XY5\r\n\t\t// \t\t\t\t// Math Vx -= Vy VY is subtracted from VX.\r\n\t\t// \t\t\t\t// VF is set to 0 when there's a borrow, and 1 when there isn't.\r\n\t\t// \t\t\t\tif (VY > VX) {\r\n\t\t// \t\t\t\t\tthis.V[0xf] = 0; // borrow\r\n\t\t// \t\t\t\t} else {\r\n\t\t// \t\t\t\t\tthis.V[0xf] = 1; // not\r\n\t\t// \t\t\t\t}\r\n\t\t// \t\t\t\tthis.V[(this.opcode & 0x0f00) >> 8] -= VY;\r\n\t\t// \t\t\t\tthis.pc += 2;\r\n\t\t// \t\t\t\tbreak;\r\n\t\t// \t\t\tcase 0x0006: // 8XY6\r\n\t\t// \t\t\t\t// BitOp Vx>>=1 Stores the least significant bit of VX in VF and then shifts VX to the right by 1.[2]\r\n\t\t// \t\t\t\tthis.V[0xf] = VX & 1;\r\n\t\t// \t\t\t\tthis.V[(this.opcode & 0x0f00) >> 8] >>= 1;\r\n\t\t// \t\t\t\tthis.pc += 2;\r\n\t\t// \t\t\t\tbreak;\r\n\t\t// \t\t\tcase 0x0007: // 8XY7\r\n\t\t// \t\t\t\t// Math Vx=Vy-Vx Sets VX to VY minus VX.\r\n\t\t// \t\t\t\t// VF is set to 0 when there's a borrow, and 1 when there isn't.\r\n\t\t// \t\t\t\tif (VX > VY) {\r\n\t\t// \t\t\t\t\tthis.V[0xf] = 0; // borrow\r\n\t\t// \t\t\t\t} else {\r\n\t\t// \t\t\t\t\tthis.V[0xf] = 1; // not\r\n\t\t// \t\t\t\t}\r\n\t\t// \t\t\t\tthis.V[(this.opcode & 0x0f00) >> 8] = VY - VX;\r\n\t\t// \t\t\t\tthis.pc += 2;\r\n\t\t// \t\t\t\tbreak;\r\n\t\t// \t\t\tcase 0x000e: // 8XYE\r\n\t\t// \t\t\t\t// BitOp Vx<<=1\r\n\t\t// \t\t\t\t// Stores the most significant bit of VX in VF and then shifts VX to the left by 1.[3]\r\n\t\t// \t\t\t\tthis.V[0xf] = VX >> 7;\r\n\t\t// \t\t\t\tthis.V[(this.opcode & 0x0f00) >> 8] <<= 1;\r\n\t\t// \t\t\t\tthis.pc += 2;\r\n\t\t// \t\t\t\tbreak;\r\n\t\t// \t\t\tdefault:\r\n\t\t// \t\t\t\tconsole.log(`Unknown opcode: ${this.opcode.toString(16)}`);\r\n\t\t// \t\t\t\tbreak;\r\n\t\t// \t\t}\r\n\t\t// \t\tbreak;\r\n\t\t// \tcase 0x9000: // 0x9XY0\r\n\t\t// \t\t// Cond if(Vx!=Vy) Skips the next instruction if VX doesn't equal VY.\r\n\t\t// \t\t// (Usually the next instruction is a jump to skip a code block)\r\n\t\t// \t\tif (VX !== VY) {\r\n\t\t// \t\t\tthis.pc += 4;\r\n\t\t// \t\t} else {\r\n\t\t// \t\t\tthis.pc += 2;\r\n\t\t// \t\t}\r\n\t\t// \t\tbreak;\r\n\t\t// \tcase 0xa000: // 0xANNN\r\n\t\t// \t\t// MEM I = NNN Sets I to the address NNN.\r\n\t\t// \t\tthis.I = this.opcode & 0x0fff;\r\n\t\t// \t\tthis.pc += 2;\r\n\t\t// \t\tbreak;\r\n\t\t// \tcase 0xb000: // 0xBNNN\r\n\t\t// \t\t// Flow PC=V0+NNN Jumps to the address NNN plus V0.\r\n\t\t// \t\t// this.pc = this.V[0] + (this.opcode & 0x0fff);\r\n\t\t// \t\tthis.pc = (this.opcode & 0x0fff) + this.V[0];\r\n\t\t// \t\tbreak;\r\n\t\t// \tcase 0xc000: // 0xCXNN\r\n\t\t// \t\t// Rand Vx=rand()&NN Sets VX to the result of a bitwise and operation on a random number (Typically: 0 to 255) and NN.\r\n\t\t// \t\trand0t255 = Math.round(Math.random() * 255);\r\n\t\t// \t\tNN = this.opcode & 0x00ff;\r\n\t\t// \t\tthis.V[(this.opcode & 0x0f00) >> 8] = rand0t255 & NN;\r\n\t\t// \t\tthis.pc += 2;\r\n\t\t// \t\tbreak;\r\n\t\t// \tcase 0xd000: // 0xDXYN\r\n\t\t// \t\t// Disp draw(Vx,Vy,N) Draws a sprite at coordinate (VX, VY) that has a width of 8 pixels and a height of N pixels. Each row of 8 pixels is read as bit-coded starting from memory location I;\r\n\t\t// \t\t// I value doesn’t change after the execution of this instruction.\r\n\t\t// \t\t// As described above, VF is set to 1 if any screen pixels are flipped from set to unset when the sprite is drawn, and to 0 if that doesn’t happen\r\n\r\n\t\t// \t\t// todo:\r\n\t\t// \t\tx = this.V[(this.opcode & 0x0f00) >> 8];\r\n\t\t// \t\ty = this.V[(this.opcode & 0x00f0) >> 4];\r\n\t\t// \t\theight = this.opcode & 0x000f;\r\n\t\t// \t\t// pixel;\r\n\r\n\t\t// \t\tthis.V[0xf] = 0;\r\n\t\t// \t\tfor (let yline = 0; yline < height; yline++) {\r\n\t\t// \t\t\tpixel = this.memory[this.I + yline];\r\n\t\t// \t\t\tfor (let xline = 0; xline < 8; xline++) {\r\n\t\t// \t\t\t\tif ((pixel & (0x80 >> xline)) != 0) {\r\n\t\t// \t\t\t\t\tif (this.gfx[x + xline + (y + yline) * 64] === 1) {\r\n\t\t// \t\t\t\t\t\tthis.V[0xf] = 1;\r\n\t\t// \t\t\t\t\t}\r\n\t\t// \t\t\t\t\tthis.gfx[x + xline + (y + yline) * 64] ^= 1;\r\n\t\t// \t\t\t\t}\r\n\t\t// \t\t\t}\r\n\t\t// \t\t}\r\n\r\n\t\t// \t\tthis.drawFlag = true;\r\n\t\t// \t\tthis.pc += 2;\r\n\t\t// \t\tbreak;\r\n\t\t// \tcase 0xe000:\r\n\t\t// \t\tswitch (this.opcode & 0x00ff) {\r\n\t\t// \t\t\tcase 0x009e: // 0xEX9E\r\n\t\t// \t\t\t\t// KeyOp if(key()==Vx) Skips the next instruction if the key stored in VX is pressed. (Usually the next instruction is a jump to skip a code block)\r\n\t\t// \t\t\t\tn = (this.opcode & 0x0f00) >> 8;\r\n\t\t// \t\t\t\tif (this.keys[this.V[n]] !== 0) {\r\n\t\t// \t\t\t\t\tthis.pc += 4;\r\n\t\t// \t\t\t\t\treturn;\r\n\t\t// \t\t\t\t} else {\r\n\t\t// \t\t\t\t\tthis.pc += 2;\r\n\t\t// \t\t\t\t}\r\n\t\t// \t\t\t\tbreak;\r\n\t\t// \t\t\tcase 0x00a1: // 0xEXA1\r\n\t\t// \t\t\t\t// KeyOp if(key()!=Vx) Skips the next instruction if the key stored in VX isn't pressed. (Usually the next instruction is a jump to skip a code block)\r\n\t\t// \t\t\t\tn = (this.opcode & 0x0f00) >> 8;\r\n\t\t// \t\t\t\tif (this.keys[this.V[n]] === 0) {\r\n\t\t// \t\t\t\t\tthis.pc += 4;\r\n\t\t// \t\t\t\t} else {\r\n\t\t// \t\t\t\t\tthis.pc += 2;\r\n\t\t// \t\t\t\t}\r\n\t\t// \t\t\t\tbreak;\r\n\t\t// \t\t\tdefault:\r\n\t\t// \t\t\t\tconsole.log(`Unknown opcode: ${this.opcode.toString(16)}`);\r\n\t\t// \t\t\t\tbreak;\r\n\t\t// \t\t}\r\n\t\t// \t\tbreak;\r\n\r\n\t\t// \tcase 0xf000:\r\n\t\t// \t\tswitch (this.opcode & 0x00ff) {\r\n\t\t// \t\t\tcase 0x0007: // 0xFX07\r\n\t\t// \t\t\t\t// Timer Vx = get_delay() Sets VX to the value of the delay timer.\r\n\t\t// \t\t\t\tthis.V[(this.opcode & 0x0f00) >> 8] = this.delay_timer;\r\n\t\t// \t\t\t\tthis.pc += 2;\r\n\t\t// \t\t\t\tbreak;\r\n\t\t// \t\t\tcase 0x000a: // 0xFX0A\r\n\t\t// \t\t\t\t// KeyOp Vx = get_key() A key press is awaited, and then stored in VX.\r\n\t\t// \t\t\t\t// (Blocking Operation. All instruction halted until next key event)\r\n\r\n\t\t// \t\t\t\tlet keyPress = false;\r\n\r\n\t\t// \t\t\t\tfor (let i = 0; i < 16; i++) {\r\n\t\t// \t\t\t\t\tif (this.keys[i] != 0) {\r\n\t\t// \t\t\t\t\t\tthis.V[(this.opcode & 0x0f00) >> 8] = i;\r\n\t\t// \t\t\t\t\t\tkeyPress = true;\r\n\t\t// \t\t\t\t\t}\r\n\t\t// \t\t\t\t}\r\n\r\n\t\t// \t\t\t\t// If we didn't received a keypress, skip this cycle and try again.\r\n\t\t// \t\t\t\tif (!keyPress) {\r\n\t\t// \t\t\t\t\treturn;\r\n\t\t// \t\t\t\t}\r\n\r\n\t\t// \t\t\t\tthis.pc += 2;\r\n\t\t// \t\t\t\tbreak;\r\n\t\t// \t\t\tcase 0x0015: // 0xFX15\r\n\t\t// \t\t\t\t// Timer delay_timer(Vx) Sets the delay timer to VX.\r\n\t\t// \t\t\t\tthis.delay_timer = VX;\r\n\t\t// \t\t\t\tthis.pc += 2;\r\n\t\t// \t\t\t\tbreak;\r\n\t\t// \t\t\tcase 0x0018: // 0xFX18\r\n\t\t// \t\t\t\t// Sound sound_timer(Vx) Sets the sound timer to VX.\r\n\t\t// \t\t\t\tthis.sound_timer = VX;\r\n\t\t// \t\t\t\tthis.pc += 2;\r\n\t\t// \t\t\t\tbreak;\r\n\t\t// \t\t\tcase 0x001e: // 0xFX1E\r\n\t\t// \t\t\t\t// MEM I +=Vx Adds VX to I.[4]\r\n\t\t// \t\t\t\t// VF is set to 1 when range overflow (I+VX>0xFFF), and 0 when there isn't.\r\n\r\n\t\t// \t\t\t\tif (this.I + VX > 0xfff) {\r\n\t\t// \t\t\t\t\tthis.V[0xf] = 1;\r\n\t\t// \t\t\t\t} else {\r\n\t\t// \t\t\t\t\tthis.V[0xf] = 0;\r\n\t\t// \t\t\t\t}\r\n\t\t// \t\t\t\tthis.I += VX;\r\n\t\t// \t\t\t\tthis.pc += 2;\r\n\t\t// \t\t\t\tbreak;\r\n\t\t// \t\t\tcase 0x0029: // 0xFX29\r\n\t\t// \t\t\t\t// MEM I=sprite_addr[Vx]\r\n\t\t// \t\t\t\t// Sets I to the location of the sprite for the character in VX.\r\n\t\t// \t\t\t\t// Characters 0-F (in hexadecimal) are represented by a 4x5 font.\r\n\t\t// \t\t\t\tthis.I = VX * 0x5;\r\n\t\t// \t\t\t\tthis.pc += 2;\r\n\t\t// \t\t\t\tbreak;\r\n\t\t// \t\t\tcase 0x0033: // 0xFX33\r\n\t\t// \t\t\t\t// BCD\tset_BCD(Vx); *(I+0)=BCD(3); *(I+1)=BCD(2); *(I+2)=BCD(1);\r\n\t\t// \t\t\t\t// Stores the binary-coded decimal representation of VX, with the most significant of three digits at the address in I,\r\n\t\t// \t\t\t\t// the middle digit at I plus 1, and the least significant digit at I plus 2. (In other words, take the decimal representation of VX,\r\n\t\t// \t\t\t\t// place the hundreds digit in memory at location in I, the tens digit at location I+1, and the ones digit at location I+2.)\r\n\t\t// \t\t\t\tthis.memory[this.I] = VX / 100;\r\n\t\t// \t\t\t\tthis.memory[this.I + 1] = (VX / 10) % 10;\r\n\t\t// \t\t\t\tthis.memory[this.I + 2] = (VX % 100) % 10;\r\n\r\n\t\t// \t\t\t\tthis.pc += 2;\r\n\t\t// \t\t\t\tbreak;\r\n\t\t// \t\t\tcase 0x0055: // 0xFX55\r\n\t\t// \t\t\t\t// MEM reg_dump(Vx,&I) Stores V0 to VX (including VX) in memory starting at address I.\r\n\t\t// \t\t\t\t// The offset from I is increased by 1 for each value written, but I itself is left unmodified.\r\n\t\t// \t\t\t\tn = (this.opcode & 0x0f00) >> 8;\r\n\r\n\t\t// \t\t\t\tfor (let i = 0; i <= n; ++i) {\r\n\t\t// \t\t\t\t\tthis.memory[this.I + i] = this.V[i];\r\n\t\t// \t\t\t\t}\r\n\r\n\t\t// \t\t\t\t// On the original interpreter, when the operation is done, I = I + X + 1.\r\n\t\t// \t\t\t\tthis.I += VX + 1;\r\n\r\n\t\t// \t\t\t\tthis.pc += 2;\r\n\r\n\t\t// \t\t\t\tbreak;\r\n\t\t// \t\t\tcase 0x0065: // 0xFX65\r\n\t\t// \t\t\t\t// MEM reg_load(Vx,&I) Fills V0 to VX (including VX) with values from memory starting at address I.\r\n\t\t// \t\t\t\t// The offset from I is increased by 1 for each value written, but I itself is left unmodified.\r\n\t\t// \t\t\t\tn = (this.opcode & 0x0f00) >> 8;\r\n\r\n\t\t// \t\t\t\tfor (let i = 0; i <= n; i++) {\r\n\t\t// \t\t\t\t\tthis.V[i] = this.memory[this.I + i];\r\n\t\t// \t\t\t\t}\r\n\r\n\t\t// \t\t\t\t// On the original interpreter, when the operation is done, I = I + X + 1.\r\n\t\t// \t\t\t\tthis.I += VX + 1;\r\n\r\n\t\t// \t\t\t\tthis.pc += 2;\r\n\r\n\t\t// \t\t\t\tbreak;\r\n\t\t// \t\t\tdefault:\r\n\t\t// \t\t\t\tconsole.log(`Unknown opcode: ${this.opcode.toString(16)}`);\r\n\t\t// \t\t\t\tbreak;\r\n\t\t// \t\t}\r\n\t\t// \t\tbreak;\r\n\r\n\t\t// \tdefault:\r\n\t\t// \t\tconsole.log(`Unknown opcode: ${this.opcode.toString(16)}`);\r\n\t\t// \t\tbreak;\r\n\t\t// }\r\n\r\n\t\t// Process opcode\r\n\t\tswitch (this.opcode & 0xf000) {\r\n\t\t\tcase 0x0000:\r\n\t\t\t\tswitch (this.opcode & 0x000f) {\r\n\t\t\t\t\tcase 0x0000: // 0x00E0: Clears the screen\r\n\t\t\t\t\t\tfor (let i = 0; i < 2048; ++i) {\r\n\t\t\t\t\t\t\tthis.gfx[i] = 0x0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis.drawFlag = true;\r\n\t\t\t\t\t\tthis.pc += 2;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 0x000e: // 0x00EE: Returns from subroutine\r\n\t\t\t\t\t\t--this.sp; // 16 levels of stack, decrease stack pointer to prevent overwrite\r\n\t\t\t\t\t\tthis.pc = this.stack[this.sp]; // Put the stored return address from the stack back into the program counter\r\n\t\t\t\t\t\tthis.pc += 2; // Don't forget to increase the program counter!\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tconsole.log(`Unknown opcode: ${this.opcode.toString(16)}`);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 0x1000: // 0x1NNN: Jumps to address NNN\r\n\t\t\t\tthis.pc = this.opcode & 0x0fff;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 0x2000: // 0x2NNN: Calls subroutine at NNN.\r\n\t\t\t\tthis.stack[this.sp] = this.pc; // Store current address in stack\r\n\t\t\t\t++this.sp; // Increment stack pointer\r\n\t\t\t\tthis.pc = this.opcode & 0x0fff; // Set the program counter to the address at NNN\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 0x3000: // 0x3XNN: Skips the next instruction if VX equals NN\r\n\t\t\t\tif (this.V[(this.opcode & 0x0f00) >> 8] == (this.opcode & 0x00ff)) {\r\n\t\t\t\t\tthis.pc += 4;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.pc += 2;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 0x4000: // 0x4XNN: Skips the next instruction if VX doesn't equal NN\r\n\t\t\t\tif (this.V[(this.opcode & 0x0f00) >> 8] != (this.opcode & 0x00ff)) {\r\n\t\t\t\t\tthis.pc += 4;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.pc += 2;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 0x5000: // 0x5XY0: Skips the next instruction if VX equals VY.\r\n\t\t\t\tif (this.V[(this.opcode & 0x0f00) >> 8] == this.V[(this.opcode & 0x00f0) >> 4]) {\r\n\t\t\t\t\tthis.pc += 4;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.pc += 2;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 0x6000: // 0x6XNN: Sets VX to NN.\r\n\t\t\t\tthis.V[(this.opcode & 0x0f00) >> 8] = this.opcode & 0x00ff;\r\n\t\t\t\tthis.pc += 2;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 0x7000: // 0x7XNN: Adds NN to VX.\r\n\t\t\t\tthis.V[(this.opcode & 0x0f00) >> 8] += this.opcode & 0x00ff;\r\n\t\t\t\tthis.pc += 2;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 0x8000:\r\n\t\t\t\tswitch (this.opcode & 0x000f) {\r\n\t\t\t\t\tcase 0x0000: // 0x8XY0: Sets VX to the value of VY\r\n\t\t\t\t\t\tthis.V[(this.opcode & 0x0f00) >> 8] = this.V[(this.opcode & 0x00f0) >> 4];\r\n\t\t\t\t\t\tthis.pc += 2;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 0x0001: // 0x8XY1: Sets VX to \"VX OR VY\"\r\n\t\t\t\t\t\tthis.V[(this.opcode & 0x0f00) >> 8] |= this.V[(this.opcode & 0x00f0) >> 4];\r\n\t\t\t\t\t\tthis.pc += 2;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 0x0002: // 0x8XY2: Sets VX to \"VX AND VY\"\r\n\t\t\t\t\t\tthis.V[(this.opcode & 0x0f00) >> 8] &= this.V[(this.opcode & 0x00f0) >> 4];\r\n\t\t\t\t\t\tthis.pc += 2;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 0x0003: // 0x8XY3: Sets VX to \"VX XOR VY\"\r\n\t\t\t\t\t\tthis.V[(this.opcode & 0x0f00) >> 8] ^= this.V[(this.opcode & 0x00f0) >> 4];\r\n\t\t\t\t\t\tthis.pc += 2;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 0x0004: // 0x8XY4: Adds VY to VX. VF is set to 1 when there's a carry, and to 0 when there isn't\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\tthis.V[(this.opcode & 0x00f0) >> 4] >\r\n\t\t\t\t\t\t\t0xff - this.V[(this.opcode & 0x0f00) >> 8]\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\tthis.V[0xf] = 1; //carry\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis.V[0xf] = 0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis.V[(this.opcode & 0x0f00) >> 8] += this.V[(this.opcode & 0x00f0) >> 4];\r\n\t\t\t\t\t\tthis.pc += 2;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 0x0005: // 0x8XY5: VY is subtracted from VX. VF is set to 0 when there's a borrow, and 1 when there isn't\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\tthis.V[(this.opcode & 0x00f0) >> 4] > this.V[(this.opcode & 0x0f00) >> 8]\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\tthis.V[0xf] = 0; // there is a borrow\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis.V[0xf] = 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis.V[(this.opcode & 0x0f00) >> 8] -= this.V[(this.opcode & 0x00f0) >> 4];\r\n\t\t\t\t\t\tthis.pc += 2;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 0x0006: // 0x8XY6: Shifts VX right by one. VF is set to the value of the least significant bit of VX before the shift\r\n\t\t\t\t\t\tthis.V[0xf] = this.V[(this.opcode & 0x0f00) >> 8] & 0x1;\r\n\t\t\t\t\t\tthis.V[(this.opcode & 0x0f00) >> 8] >>= 1;\r\n\t\t\t\t\t\tthis.pc += 2;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 0x0007: // 0x8XY7: Sets VX to VY minus VX. VF is set to 0 when there's a borrow, and 1 when there isn't\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\tthis.V[(this.opcode & 0x0f00) >> 8] > this.V[(this.opcode & 0x00f0) >> 4]\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t// VY-VX\r\n\t\t\t\t\t\t\tthis.V[0xf] = 0; // there is a borrow\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis.V[0xf] = 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis.V[(this.opcode & 0x0f00) >> 8] =\r\n\t\t\t\t\t\t\tthis.V[(this.opcode & 0x00f0) >> 4] - this.V[(this.opcode & 0x0f00) >> 8];\r\n\t\t\t\t\t\tthis.pc += 2;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 0x000e: // 0x8XYE: Shifts VX left by one. VF is set to the value of the most significant bit of VX before the shift\r\n\t\t\t\t\t\tthis.V[0xf] = this.V[(this.opcode & 0x0f00) >> 8] >> 7;\r\n\t\t\t\t\t\tthis.V[(this.opcode & 0x0f00) >> 8] <<= 1;\r\n\t\t\t\t\t\tthis.pc += 2;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tconsole.log(`Unknown opcode: ${this.opcode.toString(16)}`);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 0x9000: // 0x9XY0: Skips the next instruction if VX doesn't equal VY\r\n\t\t\t\tif (this.V[(this.opcode & 0x0f00) >> 8] != this.V[(this.opcode & 0x00f0) >> 4]) {\r\n\t\t\t\t\tthis.pc += 4;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.pc += 2;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 0xa000: // ANNN: Sets I to the address NNN\r\n\t\t\t\tthis.I = this.opcode & 0x0fff;\r\n\t\t\t\tthis.pc += 2;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 0xb000: // BNNN: Jumps to the address NNN plus V0\r\n\t\t\t\tthis.pc = (this.opcode & 0x0fff) + this.V[0];\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 0xc000: // CXNN: Sets VX to a random number and NN\r\n\t\t\t\tthis.V[(this.opcode & 0x0f00) >> 8] =\r\n\t\t\t\t\t(Math.random() * 1000) % 0xff & (this.opcode & 0x00ff);\r\n\t\t\t\tthis.pc += 2;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 0xd000: // DXYN: Draws a sprite at coordinate (VX, VY) that has a width of 8 pixels and a height of N pixels.\r\n\t\t\t\t// Each row of 8 pixels is read as bit-coded starting from memory location I;\r\n\t\t\t\t// I value doesn't change after the execution of this instruction.\r\n\t\t\t\t// VF is set to 1 if any screen pixels are flipped from set to unset when the sprite is drawn,\r\n\t\t\t\t// and to 0 if that doesn't happen\r\n\t\t\t\t{\r\n\t\t\t\t\tlet x = this.V[(this.opcode & 0x0f00) >> 8];\r\n\t\t\t\t\tlet y = this.V[(this.opcode & 0x00f0) >> 4];\r\n\t\t\t\t\tlet height = this.opcode & 0x000f;\r\n\t\t\t\t\tlet pixel;\r\n\r\n\t\t\t\t\tthis.V[0xf] = 0;\r\n\t\t\t\t\tfor (let yline = 0; yline < height; yline++) {\r\n\t\t\t\t\t\tpixel = this.memory[this.I + yline];\r\n\t\t\t\t\t\tfor (let xline = 0; xline < 8; xline++) {\r\n\t\t\t\t\t\t\tif ((pixel & (0x80 >> xline)) != 0) {\r\n\t\t\t\t\t\t\t\tif (this.gfx[x + xline + (y + yline) * 64] == 1) {\r\n\t\t\t\t\t\t\t\t\tthis.V[0xf] = 1;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tthis.gfx[x + xline + (y + yline) * 64] ^= 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.drawFlag = true;\r\n\t\t\t\t\tthis.pc += 2;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 0xe000:\r\n\t\t\t\tswitch (this.opcode & 0x00ff) {\r\n\t\t\t\t\tcase 0x009e: // EX9E: Skips the next instruction if the key stored in VX is pressed\r\n\t\t\t\t\t\tif (this.keys[this.V[(this.opcode & 0x0f00) >> 8]] != 0) {\r\n\t\t\t\t\t\t\tthis.pc += 4;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis.pc += 2;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 0x00a1: // EXA1: Skips the next instruction if the key stored in VX isn't pressed\r\n\t\t\t\t\t\tif (this.keys[this.V[(this.opcode & 0x0f00) >> 8]] == 0) {\r\n\t\t\t\t\t\t\tthis.pc += 4;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis.pc += 2;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tconsole.log(`Unknown opcode: ${this.opcode.toString(16)}`);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 0xf000:\r\n\t\t\t\tswitch (this.opcode & 0x00ff) {\r\n\t\t\t\t\tcase 0x0007: // FX07: Sets VX to the value of the delay timer\r\n\t\t\t\t\t\tthis.V[(this.opcode & 0x0f00) >> 8] = this.delay_timer;\r\n\t\t\t\t\t\tthis.pc += 2;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 0x000a: // FX0A: A key press is awaited, and then stored in VX\r\n\t\t\t\t\t\tlet keyPress = false;\r\n\r\n\t\t\t\t\t\tfor (let i = 0; i < 16; ++i) {\r\n\t\t\t\t\t\t\tif (this.keys[i] != 0) {\r\n\t\t\t\t\t\t\t\tthis.V[(this.opcode & 0x0f00) >> 8] = i;\r\n\t\t\t\t\t\t\t\tkeyPress = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// If we didn't received a keypress, skip this cycle and try again.\r\n\t\t\t\t\t\tif (!keyPress) {\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tthis.pc += 2;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 0x0015: // FX15: Sets the delay timer to VX\r\n\t\t\t\t\t\tthis.delay_timer = this.V[(this.opcode & 0x0f00) >> 8];\r\n\t\t\t\t\t\tthis.pc += 2;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 0x0018: // FX18: Sets the sound timer to VX\r\n\t\t\t\t\t\tthis.sound_timer = this.V[(this.opcode & 0x0f00) >> 8];\r\n\t\t\t\t\t\tthis.pc += 2;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 0x001e: // FX1E: Adds VX to I\r\n\t\t\t\t\t\tif (this.I + this.V[(this.opcode & 0x0f00) >> 8] > 0xfff) {\r\n\t\t\t\t\t\t\t// VF is set to 1 when range overflow (I+VX>0xFFF), and 0 when there isn't.\r\n\t\t\t\t\t\t\tthis.V[0xf] = 1;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthis.V[0xf] = 0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis.I += this.V[(this.opcode & 0x0f00) >> 8];\r\n\t\t\t\t\t\tthis.pc += 2;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 0x0029: // FX29: Sets I to the location of the sprite for the character in VX. Characters 0-F (in hexadecimal) are represented by a 4x5 font\r\n\t\t\t\t\t\tthis.I = this.V[(this.opcode & 0x0f00) >> 8] * 0x5;\r\n\t\t\t\t\t\tthis.pc += 2;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 0x0033: // FX33: Stores the Binary-coded decimal representation of VX at the addresses I, I plus 1, and I plus 2\r\n\t\t\t\t\t\tthis.memory[this.I] = this.V[(this.opcode & 0x0f00) >> 8] / 100;\r\n\t\t\t\t\t\tthis.memory[this.I + 1] = (this.V[(this.opcode & 0x0f00) >> 8] / 10) % 10;\r\n\t\t\t\t\t\tthis.memory[this.I + 2] = (this.V[(this.opcode & 0x0f00) >> 8] % 100) % 10;\r\n\t\t\t\t\t\tthis.pc += 2;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 0x0055: // FX55: Stores V0 to VX in memory starting at address I\r\n\t\t\t\t\t\tfor (let i = 0; i <= (this.opcode & 0x0f00) >> 8; ++i) {\r\n\t\t\t\t\t\t\tthis.memory[this.I + i] = this.V[i];\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// On the original interpreter, when the operation is done, I = I + X + 1.\r\n\t\t\t\t\t\t// this.I += ((this.opcode & 0x0f00) >> 8) + 1;\r\n\t\t\t\t\t\tthis.pc += 2;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 0x0065: // FX65: Fills V0 to VX with values from memory starting at address I\r\n\t\t\t\t\t\tfor (let i = 0; i <= (this.opcode & 0x0f00) >> 8; ++i) {\r\n\t\t\t\t\t\t\tthis.V[i] = this.memory[this.I + i];\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// On the original interpreter, when the operation is done, I = I + X + 1.\r\n\t\t\t\t\t\t// this.I += ((this.opcode & 0x0f00) >> 8) + 1;\r\n\t\t\t\t\t\tthis.pc += 2;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tconsole.log(`Unknown opcode: ${this.opcode.toString(16)}`);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tconsole.log(`Unknown opcode: ${this.opcode.toString(16)}`);\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// Update timers\r\n\t\tif (this.delay_timer > 0) {\r\n\t\t\t--this.delay_timer;\r\n\t\t}\r\n\r\n\t\tif (this.sound_timer > 0) {\r\n\t\t\tif (this.sound_timer === 1) {\r\n\t\t\t\tconsole.log(\"beep\\n\");\r\n\t\t\t}\r\n\t\t\t--this.sound_timer;\r\n\t\t}\r\n\r\n\t\t// case 0x0NNN:// Call Calls RCA 1802 program at address NNN. Not necessary for most ROMs.\r\n\t\t// case 0x00E0:// Display disp_clear() Clears the screen.\r\n\t\t// case 0x00EE:// Flow return; Returns from a subroutine.\r\n\t\t// case 0x1NNN:// Flow goto NNN; Jumps to address NNN.\r\n\t\t// case 0x2NNN:// Flow *(0xNNN)() Calls subroutine at NNN.\r\n\t\t// case 0x3XNN:// Cond if(Vx==NN) Skips the next instruction if VX equals NN. (Usually the next instruction is a jump to skip a code block)\r\n\t\t// case 0x4XNN:// Cond if(Vx!=NN) Skips the next instruction if VX doesn't equal NN. (Usually the next instruction is a jump to skip a code block)\r\n\t\t// case 0x5XY0:// Cond if(Vx==Vy) Skips the next instruction if VX equals VY. (Usually the next instruction is a jump to skip a code block)\r\n\t\t// case 0x6XNN:// Const Vx = NN Sets VX to NN.\r\n\t\t// case 0x7XNN:// Const Vx += NN Adds NN to VX. (Carry flag is not changed)\r\n\t\t// case 0x8XY0:// Assign Vx=Vy Sets VX to the value of VY.\r\n\t\t// case 0x8XY1:// BitOp Vx=Vx|Vy Sets VX to VX or VY. (Bitwise OR operation)\r\n\t\t// case 0x8XY2:// BitOp Vx=Vx&Vy Sets VX to VX and VY. (Bitwise AND operation)\r\n\t\t// case 0x8XY3:// BitOp Vx=Vx^Vy Sets VX to VX xor VY.\r\n\t\t// case 0x8XY4:// Math Vx += Vy Adds VY to VX. VF is set to 1 when there's a carry, and to 0 when there isn't.\r\n\t\t// case 0x8XY5:// Math Vx -= Vy VY is subtracted from VX. VF is set to 0 when there's a borrow, and 1 when there isn't.\r\n\t\t// case 0x8XY6:// BitOp Vx>>=1 Stores the least significant bit of VX in VF and then shifts VX to the right by 1.[2]\r\n\t\t// case 0x8XY7:// Math Vx=Vy-Vx Sets VX to VY minus VX. VF is set to 0 when there's a borrow, and 1 when there isn't.\r\n\t\t// case 0x8XYE:// BitOp Vx<<=1 Stores the most significant bit of VX in VF and then shifts VX to the left by 1.[3]\r\n\t\t// case 0x9XY0:// Cond if(Vx!=Vy) Skips the next instruction if VX doesn't equal VY. (Usually the next instruction is a jump to skip a code block)\r\n\t\t// case 0xANNN:// MEM I = NNN Sets I to the address NNN.\r\n\t\t// case 0xBNNN:// Flow PC=V0+NNN Jumps to the address NNN plus V0.\r\n\t\t// case 0xCXNN:// Rand Vx=rand()&NN Sets VX to the result of a bitwise and operation on a random number (Typically: 0 to 255) and NN.\r\n\t\t// case 0xDXYN:// Disp draw(Vx,Vy,N) Draws a sprite at coordinate (VX, VY) that has a width of 8 pixels and a height of N pixels. Each row of 8 pixels is read as bit-coded starting from memory location I; I value doesn’t change after the execution of this instruction. As described above, VF is set to 1 if any screen pixels are flipped from set to unset when the sprite is drawn, and to 0 if that doesn’t happen\r\n\t\t// case 0xEX9E:// KeyOp if(key()==Vx) Skips the next instruction if the key stored in VX is pressed. (Usually the next instruction is a jump to skip a code block)\r\n\t\t// case 0xEXA1:// KeyOp if(key()!=Vx) Skips the next instruction if the key stored in VX isn't pressed. (Usually the next instruction is a jump to skip a code block)\r\n\t\t// case 0xFX07:// Timer Vx = get_delay() Sets VX to the value of the delay timer.\r\n\t\t// case 0xFX0A:// KeyOp Vx = get_key() A key press is awaited, and then stored in VX. (Blocking Operation. All instruction halted until next key event)\r\n\t\t// case 0xFX15:// Timer delay_timer(Vx) Sets the delay timer to VX.\r\n\t\t// case 0xFX18:// Sound sound_timer(Vx) Sets the sound timer to VX.\r\n\t\t// case 0xFX1E:// MEM I +=Vx Adds VX to I.[4]\r\n\t\t// case 0xFX29:// MEM I=sprite_addr[Vx] Sets I to the location of the sprite for the character in VX. Characters 0-F (in hexadecimal) are represented by a 4x5 font. FX33\tBCD\tset_BCD(Vx); *(I+0)=BCD(3); *(I+1)=BCD(2); *(I+2)=BCD(1);\r\n\t\t// //Stores the binary-coded decimal representation of VX, with the most significant of three digits at the address in I, the middle digit at I plus 1, and the least significant digit at I plus 2. (In other words, take the decimal representation of VX, place the hundreds digit in memory at location in I, the tens digit at location I+1, and the ones digit at location I+2.)\r\n\t\t// case 0xFX55:// MEM reg_dump(Vx,&I) Stores V0 to VX (including VX) in memory starting at address I. The offset from I is increased by 1 for each value written, but I itself is left unmodified.\r\n\t\t// case 0xFX65:// MEM reg_load(Vx,&I) Fills V0 to VX (including VX) with values from memory starting at address I. The offset from I is increased by 1 for each value written, but I itself is left unmodified.\r\n\t}\r\n\r\n\ttick() {\r\n\t\tthis.opcode = (this.memory[this.pc] << 8) | this.memory[this.pc + 1];\r\n\r\n\t\tthis.emulateCycle();\r\n\t}\r\n}\r\n","import CPU from \"./CPU.js\";\r\nimport PPU from \"./PPU.js\";\r\n\r\nlet keyList = [\r\n\t\"1\",\r\n\t\"2\",\r\n\t\"3\",\r\n\t\"4\",\r\n\t\"Q\",\r\n\t\"W\",\r\n\t\"E\",\r\n\t\"R\",\r\n\t\"A\",\r\n\t\"S\",\r\n\t\"D\",\r\n\t\"F\",\r\n\t\"Z\",\r\n\t\"X\",\r\n\t\"C\",\r\n\t\"V\",\r\n];\r\n\r\nexport default class Chip8 {\r\n\tconstructor() {\r\n\t\tthis.cpu = new CPU();\r\n\t\tthis.ppu = new PPU(document.getElementById(\"canvas\"));\r\n\t}\r\n\r\n\tinit() {\r\n\t\tthis.cpu.init();\r\n\t\tthis.ppu.init();\r\n\t}\r\n\r\n\tloadROM(buffer) {\r\n\t\tthis.cpu.loadROM(buffer);\r\n\t}\r\n\r\n\ttick() {\r\n\t\tthis.cpu.tick();\r\n\r\n\t\tif (this.cpu.drawFlag) {\r\n\t\t\tthis.ppu.render(this.cpu.gfx);\r\n\t\t}\r\n\r\n\t\tthis.cpu.drawFlag = false;\r\n\r\n\t\t// check keyboard:\r\n\t\tfor (let i = 0; i < keyList.length; i++) {\r\n\t\t\tif (key.isPressed(keyList[i])) {\r\n\t\t\t\tthis.cpu.keys[i] = 1;\r\n\t\t\t} else {\r\n\t\t\t\tthis.cpu.keys[i] = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n","export default class PPU {\r\n\tconstructor(canvas) {\r\n\t\tthis.canvas = canvas;\r\n\t}\r\n\r\n\tinit() {\r\n\t\tthis.ctx = this.canvas.getContext(\"2d\");\r\n\t}\r\n\r\n\tdebugRender(gfx) {\r\n\t\tlet lines = \"\";\r\n\t\t// Draw\r\n\t\tfor (let y = 0; y < 32; ++y) {\r\n\t\t\tlet line = \"\";\r\n\t\t\tfor (let x = 0; x < 64; ++x) {\r\n\t\t\t\tif (gfx[y * 64 + x] == 0) {\r\n\t\t\t\t\tline += \"O\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\tline += \"X\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// line += ` ${Math.random()} ${Math.random()}`;\r\n\t\t\t// console.log(line);\r\n\t\t\tlines += line + \"\\n\";\r\n\t\t}\r\n\t\tconsole.log(lines);\r\n\t}\r\n\r\n\trender(gfx) {\r\n\t\t// this.debugRender(gfx);\r\n\t\t// this.ctx.fillRect(20, 20, 150, 100);\r\n\r\n\t\tfor (let y = 0; y < 32; ++y) {\r\n\t\t\tfor (let x = 0; x < 64; ++x) {\r\n\t\t\t\tif (gfx[y * 64 + x] == 0) {\r\n\t\t\t\t\tthis.ctx.fillStyle = \"#000\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.ctx.fillStyle = \"#FFF\";\r\n\t\t\t\t}\r\n\t\t\t\tthis.ctx.fillRect(x * 10, y * 10, 10, 10);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n","const chip8Fontset = [\r\n\t0xf0,\r\n\t0x90,\r\n\t0x90,\r\n\t0x90,\r\n\t0xf0, // 0\r\n\t0x20,\r\n\t0x60,\r\n\t0x20,\r\n\t0x20,\r\n\t0x70, // 1\r\n\t0xf0,\r\n\t0x10,\r\n\t0xf0,\r\n\t0x80,\r\n\t0xf0, // 2\r\n\t0xf0,\r\n\t0x10,\r\n\t0xf0,\r\n\t0x10,\r\n\t0xf0, // 3\r\n\t0x90,\r\n\t0x90,\r\n\t0xf0,\r\n\t0x10,\r\n\t0x10, // 4\r\n\t0xf0,\r\n\t0x80,\r\n\t0xf0,\r\n\t0x10,\r\n\t0xf0, // 5\r\n\t0xf0,\r\n\t0x80,\r\n\t0xf0,\r\n\t0x90,\r\n\t0xf0, // 6\r\n\t0xf0,\r\n\t0x10,\r\n\t0x20,\r\n\t0x40,\r\n\t0x40, // 7\r\n\t0xf0,\r\n\t0x90,\r\n\t0xf0,\r\n\t0x90,\r\n\t0xf0, // 8\r\n\t0xf0,\r\n\t0x90,\r\n\t0xf0,\r\n\t0x10,\r\n\t0xf0, // 9\r\n\t0xf0,\r\n\t0x90,\r\n\t0xf0,\r\n\t0x90,\r\n\t0x90, // A\r\n\t0xe0,\r\n\t0x90,\r\n\t0xe0,\r\n\t0x90,\r\n\t0xe0, // B\r\n\t0xf0,\r\n\t0x80,\r\n\t0x80,\r\n\t0x80,\r\n\t0xf0, // C\r\n\t0xe0,\r\n\t0x90,\r\n\t0x90,\r\n\t0x90,\r\n\t0xe0, // D\r\n\t0xf0,\r\n\t0x80,\r\n\t0xf0,\r\n\t0x80,\r\n\t0xf0, // E\r\n\t0xf0,\r\n\t0x80,\r\n\t0xf0,\r\n\t0x80,\r\n\t0x80, // F\r\n];\r\n\r\nexport default chip8Fontset;\r\n","import Chip8 from \"./Chip8.js\";\r\n\r\nfunction openFile(cb) {\r\n\tlet reader = new FileReader();\r\n\treader.onload = (event) => {\r\n\t\tlet arrayBuffer = event.target.result;\r\n\t\tlet array = new Uint8Array(arrayBuffer);\r\n\t\t// let binaryString = String.fromCharCode.apply(null, array);\r\n\t\tcb(array);\r\n\t};\r\n\treader.readAsArrayBuffer(event.target.files[0]);\r\n}\r\n\r\nfunction run(chip8) {\r\n\tchip8.tick();\r\n\tsetTimeout(run, window.tickRateMS, chip8);\r\n}\r\n\r\nfunction main() {\r\n\tlet chip8 = new Chip8();\r\n\tchip8.init();\r\n\r\n\twindow.chip8 = chip8;\r\n\r\n\tdocument.querySelector(\"input\").addEventListener(\r\n\t\t\"change\",\r\n\t\t() => {\r\n\t\t\topenFile((contents) => {\r\n\t\t\t\t// console.log(contents);\r\n\t\t\t\t// let ROM = contents.\r\n\t\t\t\tchip8.loadROM(contents);\r\n\t\t\t\trun(chip8);\r\n\t\t\t});\r\n\t\t},\r\n\t\tfalse,\r\n\t);\r\n}\r\n\r\nwindow.tickRateMS = 50;\r\n\r\nmain();\r\n"],"sourceRoot":""}